<!DOCTYPE html>
<html>

	<head>

		<title>MERLIN NOISE</title>

		<!-- For hammer.js -->
		<meta name="viewport" content="user-scalable=no, width=device-width, initial-scale=1, maximum-scale=1">

		<script type="text/javascript" src="js/hammer.js"></script>
		<script type="text/javascript" src="js/mersenne-twister.js"></script>
		<script type="text/javascript" src="js/perlin.js"></script>

		<script>

			//*****************************************************************

			// Perlin default
			var CELL_SIZE = 16;
			var CELL_GRID_SIZE = 8;
			var CELL_FREQ_1 = 4;
			var CELL_FREQ_2 = 32;
			var CELL_FREQ_3 = 128;

			// Scrolling
			var hdir = { NONE: 0, LEFT: -CELL_GRID_SIZE, RIGHT: CELL_GRID_SIZE };
			var vdir = { NONE: 0, UP: -CELL_GRID_SIZE, DOWN: CELL_GRID_SIZE };
			var m_scrollX = hdir.NONE;
			var m_scrollY = vdir.NONE;
			var m_originX = 0;
			var m_originY = 0;

			// Rendering
			var m_cellsRows = 0;
			var m_cellsLines = 0;
			var m_cellsCount = 0;
			var m_cellsSize = CELL_SIZE;
			var m_cellsGridSize = CELL_GRID_SIZE;

			// Cache cell info
			var m_cellsInfo = new Array();
			var m_cellsColor = new Array();

			// Gl canvas/context
			var glCanvas = null;
			var glCanvas2 = null;
			var glContext = null;
			var glContext2 = null;
			var m_domVersionActivated = false;
			var m_forceUpdateColors = false;

			//*****************************************************************

			function updateGridSize(gridSize) {
				if (gridSize < 1)
					return;

				m_cellsGridSize = gridSize;
				hdir = { NONE: 0, LEFT: -m_cellsGridSize, RIGHT: m_cellsGridSize };
				vdir = { NONE: 0, UP: -m_cellsGridSize, DOWN: m_cellsGridSize };

				m_forceUpdateColors = true;
			}

			//*****************************************************************

			function clearCells() {
				let domCanvas = document.getElementById('domCanvas');
				if (domCanvas) {
					while (domCanvas.firstChild) {
						domCanvas.removeChild(domCanvas.firstChild);
					}
				}
			}

			//*****************************************************************

			function hashFnv32a(str) {
			    /*jshint bitwise:false */
			    var i, l, hval = 0x811c9dc5;

			    for (i = 0, l = str.length; i < l; i++) {
			        hval ^= str.charCodeAt(i);
			        hval += (hval << 1) + (hval << 4) + (hval << 7) + (hval << 8) + (hval << 24);
			    }
			    return hval >>> 0;
			}

			//*****************************************************************

			function getCellHash(row, line) {
				return hashFnv32a('r:' + row + 'l:' + line);
			}

			//*****************************************************************

			function createCells() {
				let domCanvas = document.getElementById('domCanvas');
				if (domCanvas) {

					m_cellsInfo.length = 0;
					m_cellsColor.length = 0;
					clearCells();

					if (m_domVersionActivated) {
						m_cellsRows = Math.floor(domCanvas.offsetWidth / m_cellsSize) + 1;
						m_cellsLines = Math.floor(domCanvas.offsetHeight / m_cellsSize) + 1;
					} else {
						m_cellsRows = Math.floor(glContext.canvas.width / m_cellsSize) + 1;
						m_cellsLines = Math.floor(glContext.canvas.height / m_cellsSize) + 1;
					}
					m_cellsCount = m_cellsRows * m_cellsLines;

					for (line = 0; line < m_cellsLines; line++) {
						for (row = 0; row < m_cellsRows; row++) {
							let x = row * m_cellsSize;
							let y = line * m_cellsSize;
							let index = row + (line * m_cellsRows);

							let cell = 0;
							if (m_domVersionActivated) {
								cell = document.createElement("cell");
								cell.className = 'cell';
								cell.style.marginTop = y + 'px';
								cell.style.marginLeft = x + 'px';
								cell.style.width = m_cellsSize + 'px';
								cell.style.height = m_cellsSize + 'px';
								domCanvas.appendChild(cell);
							}

							m_cellsInfo.push({cell: cell, 
								index: index, 
								row: row, 
								line: line, 
								x: x, 
								y: y, 
							});
							m_cellsColor.push(getCellColor(row, line));
						}
					}
				}
			}

			//*****************************************************************

			function getCellColor(row, line) {
				let x = m_originX + row * m_cellsGridSize;
				let y = m_originY + line * m_cellsGridSize;
				let v = 0.1 * perlin.get(x / CELL_FREQ_1, y / CELL_FREQ_1)
					+ 0.2 * perlin.get(x / CELL_FREQ_2, y / CELL_FREQ_2)
					+ 0.9 * perlin.get(x / CELL_FREQ_3, y / CELL_FREQ_3)
				return  'hsl(' + (v * 400) + ', 75%, 50%)';
			}

			//*****************************************************************

			function updateCells() {
				var perlinTimeMs = 0;
				var domDrawTimeMs = 0;
				var glDrawTimeMs = 0;
				
				// PERLIN CALCULATION
				var now = performance.now();
				if (m_forceUpdateColors) {
					m_forceUpdateColors = false;
					m_cellsInfo.forEach(function(cellInfo) {
						m_cellsColor[cellInfo.index] = getCellColor(cellInfo.row, cellInfo.line);
					});
				}
				else {
					if (m_scrollX < 0) {
						m_cellsColor.pop();
						m_cellsColor.unshift(getCellColor(0, 0));
						for (let index = 0; index < m_cellsCount; index += m_cellsRows) {
							m_cellsColor[index] = getCellColor(m_cellsInfo[index].row, m_cellsInfo[index].line);
						}
					}
					else if (m_scrollX > 0) {
						m_cellsColor.shift();
						m_cellsColor.push(getCellColor(m_cellsRows - 1, m_cellsLines - 1));
						for (let index = m_cellsRows - 1; index < m_cellsCount; index += m_cellsRows) {
							m_cellsColor[index] = getCellColor(m_cellsInfo[index].row, m_cellsInfo[index].line);
						}
					}

					if (m_scrollY < 0) {
						m_cellsColor = m_cellsColor.slice(0, m_cellsCount - m_cellsRows);
						let index = m_cellsRows;
						while (index--) {
							m_cellsColor.unshift(getCellColor(m_cellsInfo[index].row, m_cellsInfo[index].line));
						}
					}
					else if (m_scrollY > 0) {
						m_cellsColor = m_cellsColor.slice(m_cellsRows, m_cellsCount);
						let index = m_cellsCount - m_cellsRows - 1;
						while (index++ < m_cellsCount - 1) {
							m_cellsColor.push(getCellColor(m_cellsInfo[index].row, m_cellsInfo[index].line));
						}
					}
				}
				perlinTimeMs += performance.now() - now;

				m_cellsInfo.forEach(function(cellInfo) {
					// UPDATING DOM
					if (m_domVersionActivated) {
						now = performance.now();
						cellInfo.cell.style.backgroundColor = m_cellsColor[cellInfo.index];
						//cellInfo.cell.style.border = 'solid 1px hsl(' + v + ', 40%, 40%)';
						domDrawTimeMs += performance.now() - now;
					}

					// DRAW GL
					now = performance.now();
					glContext2.fillStyle = m_cellsColor[cellInfo.index];
					glContext2.fillRect(cellInfo.x, cellInfo.y, m_cellsSize, m_cellsSize);
					glDrawTimeMs += performance.now() - now;
				});

				now = performance.now();
				glContext.drawImage(glCanvas2, 0, 0);
				glDrawTimeMs += performance.now() - now;

				let divDebugPerf = document.getElementById('divDebugPerf');
				if (divDebugPerf) {
					divDebugPerf.innerHTML = 'Noise calc. = ' + perlinTimeMs.toFixed(2) + 'ms<br>' +
						'DOM draw = ' + domDrawTimeMs.toFixed(2) + 'ms<br>' +
						'GL Draw = ' + glDrawTimeMs.toFixed(2) + 'ms';
				}
			}

			//*****************************************************************

			function createGl() {
				glContext = null;
				glContext2 = null;

				glCanvas = document.getElementById('glCanvas');
				if (glCanvas) {
					glContext = glCanvas.getContext('2d');

					glCanvas2 = document.createElement('canvas');
					if (glCanvas2) {
						glContext2 = glCanvas2.getContext('2d');
					}
				}

				if (glContext && glContext2) {
					resizeGl();
				}
				else {
					console.log('ERROR: Cannot get 2d context!');
				}
			}

			//*****************************************************************

			function resizeGl() {
				let glCanvasContainer = document.getElementById('glCanvasContainer');
				if (glCanvasContainer) {
					glCanvasContainer.style.marginLeft = m_domVersionActivated ? '50%' : '0';
					glCanvasContainer.style.width = m_domVersionActivated ? '50%' : '100%';
					glCanvas.width = glCanvasContainer.clientWidth;
					glCanvas.height = glCanvasContainer.clientHeight;
					glCanvas2.width = glCanvasContainer.clientWidth;
					glCanvas2.height = glCanvasContainer.clientHeight;
				}
				glContext.imageSmoothingEnabled = false;
				glContext2.imageSmoothingEnabled = false;
			}

			//*****************************************************************

			function switchDomRendering() {
				m_domVersionActivated = !m_domVersionActivated;

				resizeGl();	// This must be called before createCells()!
				createCells();
			}

			//*****************************************************************

			function scroll() {
				m_originX += m_scrollX;
				m_originY += m_scrollY;
				updateCells();
			}

			//*****************************************************************

			window.onload = function() {
				var canvasParent = document.getElementById('canvasParent');
				if (canvasParent) {
					var hammertime = new Hammer(canvasParent);
					hammertime.on('pan', function(ev) {
						//console.log(ev.deltaX + ' ' + ev.deltaY);
						if (Math.abs(ev.deltaX) > 16) {
							m_scrollX = ev.deltaX / Math.abs(ev.deltaX);
						}
						if (Math.abs(ev.deltaY) > 16) {
							m_scrollY = ev.deltaY / Math.abs(ev.deltaY);
						}
						scroll();
						m_scrollX = 0;
						m_scrollY = 0;
					});
				}

				createGl();
				createCells();
				setInterval(function() { scroll() }, 50);
			}

			window.onresize = function() {
				resizeGl();
				createCells();
			}

			document.onkeydown = function(e) { 
				switch (e.keyCode) { 
				case 37: m_scrollX = hdir.LEFT; break; 
				case 38: m_scrollY = vdir.UP; break; 
				case 39: m_scrollX = hdir.RIGHT; break; 
				case 40: m_scrollY = vdir.DOWN; break; 
				}
			}

			document.onkeyup = function(e) { 
				switch (e.keyCode) { 
				case 37: m_scrollX = hdir.NONE; break; 
				case 38: m_scrollY = vdir.NONE; break; 
				case 39: m_scrollX = hdir.NONE; break; 
				case 40: m_scrollY = vdir.NONE; break;
				case 65: 
					m_cellsSize++;
					createCells();
					break;
				case 66: 
					m_cellsSize--;
					createCells();
					break;
				case 67:
					switchDomRendering();
					break;
				}
			}

			document.onmousewheel = function(e) {
				if (e.deltaY < 0) {
					updateGridSize(m_cellsGridSize - 1);
				}
				else if (e.deltaY > 0) {
					updateGridSize(m_cellsGridSize + 1);
				}
			}

		</script>
			
		<link rel="stylesheet" href="css/index.css" />

	</head>

<body>

<!-- DOM and GL CANVAS -->
<div class="canvasParent" id ="canvasParent">
<div class="canvas" id="domCanvas"></div>
<div class="canvas glcanvas" id="glCanvasContainer">
	<canvas id="glCanvas"></canvas>
</div>
</div>

<!-- DEBUG PANEL -->
<div class="debug background"></div>
<div class="debug">
	<div><b>Debug Information</b></div>
	<div class="perf" id="divDebugPerf"></div>
</div>

</body>

</html>